<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title></title>
	<meta charset="utf-8" />
    <link rel="stylesheet" href="scripts/reset.css" />
    <script src="scripts/jquery-1.8.2.js"></script>
    <script src="scripts/three.min.js"></script>
    <script src="scripts/DDSLoader.js"></script>
    <script src="scripts/stats.min.js"></script>
    <script src="scripts/dat.gui.min.js"></script>
    <script src="scripts/OrbitControls.js"></script>
    <script src="scripts/GLTFLoader.js"></script>
    <script src="scripts/FirstPersonControls.js"></script>
    <script>
        var jsonData;
        function mouseClick(bim_uid) {
            var xml = $.parseXML(jsonData[bim_uid]);
            getmessage(xml);
        }
            
        var getBiminfo = function () {
            $.ajax({
                type: "POST",
                url: "/Handler3D.ashx?action=getbiminfo",
                dataType: "html",
                data: {
                },
                timeout: 20000,
                success: function (data) {
                    jsonData = $.parseJSON(data);
                }
            });
        };
        getBiminfo();
        var M_DOT = 1;
        function fn(obj) {
            var dotString = "";
            for (j = 1; j <= M_DOT; j++) {
                dotString += "----";
            }
            var myObj = obj[0].attributes;
            $("#c").append(dotString)
            $(myObj).each(function (i) {
                var nodeJson = $.parseJSON($(this)[0].nodeValue);
                var arrayObj = new Array();
                if (nodeJson.Name != undefined) {
                    arrayObj.push(nodeJson.Name);
                } if (nodeJson.NominalValue != undefined) {
                    arrayObj.push(nodeJson.NominalValue);
                }
                if (arrayObj.length == 1) {
                    $("#c").append("<u>" + arrayObj.pop() + "</u> ");
                } else {
                    $("#c").append("<u>" + arrayObj.shift() + " = " + arrayObj.pop() + "</u> ");
                }
            })
            $("#c").append("<br/>");
            if (obj.length > 0) {
                obj.children().each(function (i) {
                    M_DOT++;
                    fn($(this));
                    M_DOT--;
                })
            } else {
                return false;
            }
        }
        function getmessage(xml) {
            $("#c").empty();
            $(xml).find('*:first').each(function (i) {
                fn($(this));
            });
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        function change() {
            Go = window.setTimeout(function () {
                if (scene.getObjectByName("product-6ba06933-8c60-4f79-9c9c-0e53569806f4-body") != undefined) {
                    clearTimeout(Go);
                    updateMesh();
                } else {
                    change();
                }
            }, 1000)
        }
        change();

        function changeRun() {
            scene.getObjectByName("product-1eb10804-77e2-4d38-91a8-740eae813669-body").material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        }
        function changeStop() {
            scene.getObjectByName("product-1eb10804-77e2-4d38-91a8-740eae813669-body").material = new THREE.MeshBasicMaterial({ color: 0x909090 });
        }
        function changeError() {
            scene.getObjectByName("product-1eb10804-77e2-4d38-91a8-740eae813669-body").material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        }
        function changeNormal() {
            scene.getObjectByName("product-1eb10804-77e2-4d38-91a8-740eae813669-body").material = new THREE.MeshBasicMaterial({ color: 0x909090 });
        }
        var elem;//= document.getElementById('canvas3d');
        document.addEventListener("mousemove", function (e) {
            var movementX = e.movementX ||
						  e.mozMovementX ||
						  e.webkitMovementX ||
						  0,
			movementY = e.movementY ||
						  e.mozMovementY ||
						  e.webkitMovementY ||
						  0;
            //console.log("movementX=" + movementX, "movementY=" + movementY);
        }, false);

        function fullscreenChange() {
            if (document.webkitFullscreenElement === elem ||
                document.mozFullscreenElement === elem ||
                document.mozFullScreenElement === elem) { // 较旧的 API 大写 'S'.
                // 元素进入全屏模式了，现在我们可以请求指针锁定。
                elem.requestPointerLock = elem.requestPointerLock ||
                                          elem.mozRequestPointerLock ||
                                          elem.webkitRequestPointerLock;
                elem.requestPointerLock();
            }
        }

        document.addEventListener('fullscreenchange', fullscreenChange, false);
        document.addEventListener('mozfullscreenchange', fullscreenChange, false);
        document.addEventListener('webkitfullscreenchange', fullscreenChange, false);

        function pointerLockChange() {
            if (document.mozpointerLockElement === elem ||
				document.webkitpointerLockElement === elem ||
				document.pointerLockElement === elem) {
                controls.dispose();
                initControls();
                document.getElementById("crosshair").style.opacity = 1;
            } else {
                controls.dispose();
                initControls1();
                document.getElementById("crosshair").style.opacity = 0;
            }
        }

        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);

        function pointerLockError() {
            console.log("锁定指针时出错。");
        }

        document.addEventListener('pointerlockerror', pointerLockError, false);
        document.addEventListener('mozpointerlockerror', pointerLockError, false);
        document.addEventListener('webkitpointerlockerror', pointerLockError, false);

        function changePointer() {
            elem = document.getElementById("canvas3d");
            elem.requestFullscreen = elem.requestFullscreen ||
                                     elem.mozRequestFullscreen ||
                                     elem.mozRequestFullScreen || // 较旧的 API 把 ‘S’ 大写
                                     elem.webkitRequestFullscreen;
            //elem.requestFullscreen();
            elem.requestPointerLock();
        }


       
        //定义objects数组用于存放模型里所有的Mesh
        var objects = [];
        //声明raycaster和mouse变量
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var meshMaterial = new THREE.MeshBasicMaterial();
        window.addEventListener('click', onMouseClick, false);
        function onMouseClick(event) {
            event.preventDefault();
            //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.
            mouse.x = ((event.clientX) / window.innerWidth) * 2 - 1;
            mouse.y = -((event.clientY) / window.innerHeight) * 2 + 1;
            // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
            raycaster.setFromCamera(mouse, camera);
            // 获取raycaster直线和所有模型相交的数组集合
            var intersects = raycaster.intersectObjects(objects);
            for (var i = 0; i < intersects.length; i = intersects.length) {
                //材质信息
                var namearray = new Array();
                namearray = intersects[0].object.material.name.split('-');
                //console.log(namearray[namearray.length - 1]);
                var meshName = intersects[0].object.name;
                var reg = new RegExp("[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}");
                meshName.match(reg) == null ? $("#c").empty() : mouseClick(meshName.match(reg).toString());
                /*var texture = new THREE.TextureLoader().load("test.jpg", function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.offset.set(0, 0);
                    texture.repeat.set(1, 1)
                });*/
                var texture = new THREE.TextureLoader().load("test.jpg");
                texture.minFilter = texture.magFilter = THREE.LinearFilter;
                texture.mapping = THREE.UVMapping;
                var Material = new THREE.MeshPhongMaterial({ map: texture });
                intersects[0].object.material = Material;
                //var textureLoader = new THREE.TextureLoader();
                /*textureLoader.load("test.jpg", function (texture) {
                    textureLoader.load("test.jpg", function (normalTexture) {
                        intersects[0].object.material.map = texture;
                        intersects[0].object.material.normalMap = normalTexture; // 只要将法向贴图赋给材质的normalMap属性即可
                        intersects[0].object.material.needsUpdate = true;
                    });
                });*/
                //intersects[0].object.material.map = texture;
                //intersects[0].object.material.needsUpdate = true;//材质会更新
                //intersects[0].object.material = Material;
               /* var materialClass = {
                    opacity: meshMaterial.opacity,
                    transparent: meshMaterial.transparent
                }
                
                var Material = new THREE.MeshBasicMaterial();
                Material = intersects[0].object.material;
                Material.transparent = meshMaterial.transparent;
                Material.opacity = meshMaterial.opacity;
                meshMaterial = new THREE.MeshBasicMaterial(Material);
                intersects[0].object.material = meshMaterial;
                //动画可删除*/
                function draw() {
                    intersects[0].object.rotation.z = (intersects[0].object.rotation.z + 0.01) % (Math.PI * 2);
                }
                //var sss = setInterval(draw, 1);
            }
        }
        
        //窗口更新函数
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            //controls.handleResize();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        //世界坐标
        function initAxis() {
            var axes = new THREE.AxisHelper(1000);
            scene.add(axes);
        }

        function initThree() {
            width = window.innerWidth;
            height = window.innerHeight;
            //渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            document.getElementById("canvas3d").appendChild(renderer.domElement);
            renderer.setClearColor(0x000000, 1.0);	//0x73a1bf	
        }
        //相机一，查看全景
        var camera;
        function initCamera1() {
            camera = new THREE.PerspectiveCamera(45, width / height, 1, 2000);
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 20;

            /*camera.up.x = 0;
            camera.up.z = 1;
           	camera.up.y = 0;
			camera.lookAt({x:0,y:0,z:0});*/

            camera.up.x = 0;
            camera.up.z = 0;
            camera.up.y = 1;
            //cameraTarget = new THREE.Vector3(0, 0, 0);	
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            //iscontrol1=true;
            //iscontrol2=false;
            //iscontrol3 = false;
        }
        //总体浏览控制器
        var controls;
        function initControls1() {
            controls = null;
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            // 如果使用animate方法时，将此函数删除
            //controls.addEventListener( 'change', render );
            // 使动画循环使用时阻尼或自转 意思是否有惯性
            controls.enableDamping = false;
            //动态阻尼系数 就是鼠标拖拽旋转灵敏度
            controls.dampingFactor = 0.1;
            //是否可以缩放
            controls.enableZoom = true;
            //是否自动旋转
            controls.autoRotate = false;
            //设置相机距离原点的最远距离
            controls.minDistance = 1;
            //设置相机距离原点的最远距离
            controls.maxDistance = 1000;
            //是否开启右键拖拽 
            controls.enablePan = true;
        }
        //第一人称浏览控制器
        function initControls() {
            controls = null;
            controls = new THREE.FirstPersonControls(camera, renderer.domElement);
            controls.lookSpeed = 0.1; //鼠标移动查看的速度
            controls.movementSpeed = 1; //相机移动速度
            controls.noFly = false;
            controls.constrainVertical = false; //约束垂直
        }
        var scene;
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x72645b, 10, 1000);
        }

        function initLight() {

            //自然光
            light = new THREE.AmbientLight(0x0c0c0c);
            scene.add(light);
            //半球光
            var hemiLight = new THREE.HemisphereLight(0xffffff, 0xfcfcfc);
            hemiLight.position.set(0, 15000, 0);
            scene.add(hemiLight);
            //太阳光
            var light2 = new THREE.SpotLight(0x00bfff, 0.5, 34000);
            light2.position.set(14000, 10000, 12000);
            scene.add(light2);

        }

        function loadGLTF(path, fileName) {
            var loader = new THREE.GLTFLoader();
            loader.load('./model/123.gltf', function (gltf) {
                let object = gltf.scene;
                object.rotation.x = THREE.Math.degToRad(-90);
                object.rotation.z = THREE.Math.degToRad(180);
                //模型居中
                var box = new THREE.Box3();
                //计算点击Mesh的几何中心
                var boxobj = box.expandByObject(object);
                object.position.x = -(boxobj.max.x + boxobj.min.x) / 2;
                object.position.y = -(boxobj.max.y + boxobj.min.y) / 2;
                object.position.z = -(boxobj.max.z + boxobj.min.z) / 2;
                traverseTree(object)

                function traverseNode(obj) {
                    if (obj.type == "Mesh") {
                        //var axes = new THREE.BoxHelper(node,0xff0000);
                        //scene.add(axes);
                        var texture = new THREE.TextureLoader().load("test.jpg")
                        obj.material.map = texture;
                        objects.push(obj);
                    }
                }
                function traverseTree(obj) {
                    if (!object) {
                        return;
                    }
                    traverseNode(obj);
                    if (obj.children && obj.children.length > 0) {
                        for (var i = 0; i < obj.children.length; i++) {
                            traverseTree(obj.children[i]);
                        }
                    }
                }
                //object.children.forEach(function (children) {});
                scene.add(object);
                //创建新的object3D对象并将position设置为点击Mesh的几何中心
                //将点击Mesh add到新建的object3D对象并调用center()居中
                //var newobj = NewObject3D(x, y, z, obj);
                //将新建的object3D对象add到scene
                //新建立方体模型
                /*var texture = new THREE.TextureLoader().load("test.png")
                var geometry = new THREE.BufferGeometry();
                var vertexPositions = new Float32Array([-1, -1, -1],
                                        [1, -1, -1],
                                        [1, -1, 1],
                                        [-1, -1, 1],
                                        [-1, 1, 1],
                                        [-1, 1, -1],
                                        [1, 1, -1],
                                        [1, 1, 1]);
                var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
                /*for (var i = 0; i < vertexPositions.length; i++) {
                    vertices[i * 3 + 0] = vertexPositions[i][0];
                    vertices[i * 3 + 1] = vertexPositions[i][1];
                    vertices[i * 3 + 2] = vertexPositions[i][2];
                }*/
               /*geometry.addAttribute('position', new THREE.BufferAttribute(vertexPositions, 3));
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var mesh = new THREE.Mesh(geometry, material);*/
               
                var geometry = new THREE.BoxGeometry(2, 2, 2);
                var bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);
                var texture = new THREE.TextureLoader().load("test.png")
                var material = new THREE.MeshBasicMaterial({ map : texture });
                var cube = new THREE.Mesh(bufferGeometry, material);
                
                /*var geom = new THREE.BoxGeometry(1, 10, 10);
                var buffgeom = new THREE.BufferGeometry();
                buffgeom.fromGeometry(geom);
                var texture = THREE.ImageUtils.loadTexture("test.png");
                var mat = new THREE.MeshPhongMaterial({ map: texture, side: THREE.DoubleSide });
                var mesh = new THREE.Mesh(buffgeom, mat);*/
                objects.push(cube);
                scene.add(cube);
               // scene.add(mesh);
            });
        }

        function NewObject3D(x, y, z, obj) {
            let New3D = new THREE.Object3D()
            New3D.add(obj);
            New3D.position.set(x, y, z);
            obj.geometry.center();
            obj.rotation.x = THREE.Math.degToRad(90);
            obj.rotation.z = THREE.Math.degToRad(-180);
            console.log(obj.name);
            return New3D;
        }

        function updateMesh() {
            var box = new THREE.Box3();
            var obj = scene.getObjectByName("product-6ba06933-8c60-4f79-9c9c-0e53569806f4-body");
            var boxobj = box.expandByObject(obj);
            var x = (boxobj.max.x + boxobj.min.x) / 2;
            var y = (boxobj.max.y + boxobj.min.y) / 2;
            var z = (boxobj.max.z + boxobj.min.z) / 2;
            var newobj = NewObject3D(x, y, z, obj);
            objects.push(newobj.children[0]);
            scene.add(newobj);
        }

        function threeStart() {
            initThree();
            initCamera1();
            initScene();
            initLight();
            initGui();
            initStats();
            loadGLTF('model/', '123');
            //控制器	
            initControls1();
            //initControls();
            animate();
            //updateMesh();
            initAxis();
        }
        var clock = new THREE.Clock();
        function render() {
            //			全局视角						
            //controls.update();
            controls.update(clock.getDelta());
            renderer.render(scene, camera);
            window.onresize = onWindowResize;
        }

        function animate() {
            render();
            requestAnimationFrame(animate);
            stats.update();
        }
        var spGui;
        function initGui() {
            //声明一个保存需求修改的相关数据的对象
            guidata = {
                rotationSpeed: 0.02,
                bouncingSpeed: 0.03,
                opacity: meshMaterial.opacity,
                transparent: meshMaterial.transparent,
                overdraw: meshMaterial.overdraw,
                visible: meshMaterial.visible,
                side: "front",
                color: meshMaterial.color.getStyle(),
                wireframe: meshMaterial.wireframe,
                wireframeLinewidth: meshMaterial.wireframeLinewidth,
                wireFrameLineJoin: meshMaterial.wireframeLinejoin,
            };

            var gui = new dat.GUI();
            spGui = gui.addFolder("菜单");
            spGui.add(guidata, 'opacity', 0, 1).onChange(function (e) {
                meshMaterial.opacity = e
            });
            spGui.add(guidata, 'transparent').onChange(function (e) {
                meshMaterial.transparent = e
            });
            spGui.add(guidata, 'wireframe').onChange(function (e) {
                meshMaterial.wireframe = e
            });
            spGui.add(guidata, 'wireframeLinewidth', 0, 20).onChange(function (e) {
                console.log(e);
                meshMaterial.wireframeLinewidth = e
            });
            spGui.add(guidata, 'visible').onChange(function (e) {
                meshMaterial.visible = e
            });
            spGui.add(guidata, 'side', ["front", "back", "double"]).onChange(function (e) {
                console.log(e);
                switch (e) {
                    case "front":
                        meshMaterial.side = THREE.FrontSide;
                        break;
                    case "back":
                        meshMaterial.side = THREE.BackSide;
                        break;
                    case "double":
                        meshMaterial.side = THREE.DoubleSide
                        break;
                }
                meshMaterial.needsUpdate = true;
                console.log(meshMaterial);
            });
            spGui.addColor(guidata, 'color').onChange(function (e) {
                meshMaterial.color.setStyle(e)
            });
            spGui.open();

        }
        //初始化性能插件
        var stats;
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
    </script>
</head>
<body onload='threeStart();'>
    <div id="c" style="position: absolute;left: 10px;top: 60px;height:auto"></div>
    <div id="canvas3d" />
    <div id="crosshair"></div>
</body>
</html>



